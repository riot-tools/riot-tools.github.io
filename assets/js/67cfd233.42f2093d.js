"use strict";(self.webpackChunkriot_tools=self.webpackChunkriot_tools||[]).push([[788],{813:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return r},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return u},default:function(){return d}});var a=t(7462),i=t(3366),o=(t(7294),t(3905)),s=["components"],r={id:"meiosis-types",title:"Types",sidebar_label:"Types",slug:"/meiosis/types"},c=void 0,l={unversionedId:"meiosis/meiosis-types",id:"meiosis/meiosis-types",isDocsHomePage:!1,title:"Types",description:"createStateStream",source:"@site/docs/meiosis/types.md",sourceDirName:"meiosis",slug:"/meiosis/types",permalink:"/meiosis/types",editUrl:"https://github.com/riot-tools/riot-tools.github.io/edit/master/meiosis/docs/meiosis/types.md",version:"current",frontMatter:{id:"meiosis-types",title:"Types",sidebar_label:"Types",slug:"/meiosis/types"},sidebar:"meiosis",previous:{title:"API",permalink:"/meiosis/api"}},u=[{value:"<code>createStateStream</code>",id:"createstatestream",children:[]},{value:"<code>Manager</code>",id:"manager",children:[]},{value:"<code>ConnectFunction</code>",id:"connectfunction",children:[]}],p={toc:u};function d(e){var n=e.components,t=(0,i.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h3",{id:"createstatestream"},(0,o.kt)("inlineCode",{parentName:"h3"},"createStateStream")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"declare type AnyState = Object | Array<any> | String | Map<any, any> | Set<any>;\n\ndeclare const createStateStream: (initialState: AnyState, options?: ManagerOptions) => {\n    stream: Manager;\n    connect: ConnectFunction;\n    update: (value: any) => Manager;\n};\n")),(0,o.kt)("h3",{id:"manager"},(0,o.kt)("inlineCode",{parentName:"h3"},"Manager")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"\ndeclare type ManagerOptions = {\n    /** How many states changes to keep in memory */\n    statesToKeep?: number;\n    /** Removes states after reading */\n    flushOnRead?: boolean;\n    /** Parent stream */\n    parent?: Manager;\n    /** Child stream should update parent stream */\n    bidirectional?: boolean;\n};\n\ndeclare type ManagerState = {\n    state?: any;\n    currentState?: number | null;\n    latestState?: number | null;\n    parentListener?: Function | null;\n    childListener?: Function | null;\n};\n\ndeclare type ModifierFunction = (value: any, state?: any, ignore?: symbol) => any;\n\ndeclare class Manager {\n    _options: ManagerOptions | null;\n    private _id;\n    private _sid;\n    private _stateId;\n    _internals: ManagerState;\n    _states: Map<number, any> | null;\n    _modifiers: Set<ModifierFunction> | null;\n    _listeners: Set<Function> | null;\n    _parent: Manager | null;\n    constructor(initialState?: any, options?: ManagerOptions);\n    private _setInternals;\n    private _addState;\n    private _notifyListeners;\n    execs: number;\n    update(value: any, flow?: Manager[]): this;\n    modify(func: ModifierFunction): this;\n    unmodify(func: ModifierFunction): this;\n    listen(func: Function): this;\n    unlisten(func: Function): this;\n    states(): any[];\n    state(): any;\n    flushStates(): void;\n    resetState(): void;\n    private _stateStepper;\n    prevState(): void;\n    nextState(): void;\n    clone(options?: ManagerOptions): Manager;\n    private _setupClone;\n}\n")),(0,o.kt)("h3",{id:"connectfunction"},(0,o.kt)("inlineCode",{parentName:"h3"},"ConnectFunction")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"interface ConnectFunction {\n    (component: RiotComponentExport): RiotComponentExport;\n}\ndeclare const connectFactory: (stateStream: Manager) => ConnectFunction;\n")))}d.isMDXComponent=!0}}]);