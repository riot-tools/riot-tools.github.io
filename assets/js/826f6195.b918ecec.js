"use strict";(self.webpackChunkriot_tools=self.webpackChunkriot_tools||[]).push([[389],{3703:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return m},toc:function(){return d},default:function(){return u}});var i=t(7462),a=t(3366),o=(t(7294),t(3905)),r=["components"],l={id:"final-form-getting-started",title:"Getting Started",sidebar_label:"Getting Started",slug:"/final-form/getting-started"},s=void 0,m={unversionedId:"final-form/final-form-getting-started",id:"final-form/final-form-getting-started",isDocsHomePage:!1,title:"Getting Started",description:"If you don't know what Final Form is, you are either probably a masochist, or have never dealt with forms on web pages. If you come from the world of React, you might be familiar with this tool already. It is similar to Formik and React Hook Form.",source:"@site/docs/final-form/getting-started.md",sourceDirName:"final-form",slug:"/final-form/getting-started",permalink:"/final-form/getting-started",editUrl:"https://github.com/riot-tools/riot-tools.github.io/edit/master/meiosis/docs/final-form/getting-started.md",version:"current",frontMatter:{id:"final-form-getting-started",title:"Getting Started",sidebar_label:"Getting Started",slug:"/final-form/getting-started"},sidebar:"finalForm",next:{title:"API",permalink:"/final-form/api"}},d=[{value:"Usage",id:"usage",children:[]},{value:"Manually initialize final form",id:"manually-initialize-final-form",children:[{value:"Example",id:"example",children:[]}]}],f={toc:d};function u(e){var n=e.components,t=(0,a.Z)(e,r);return(0,o.kt)("wrapper",(0,i.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"If you don't know what ",(0,o.kt)("a",{parentName:"p",href:"https://final-form.org/"},"Final Form")," is, you are either probably a masochist, or have never dealt with forms on web pages. If you come from the world of React, you might be familiar with this tool already. It is similar to Formik and React Hook Form."),(0,o.kt)("p",null,"To sum it up, it is a framework-agnostic, minimalistic form validation library. For us it was a no-brainer to implement this for Riot. You should understand Final Form first before you attempt to use this tool with Riot so you are not confused as to the implementation."),(0,o.kt)("h2",{id:"usage"},"Usage"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"npm i -S @riot-tools/final-form\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<some-form>\n\n    <form>\n\n        <div class="field">\n            <label for="name">Name</label>\n            <input type="text" id="name" name="name" />\n            <div class="error"></div>\n        </div>\n        <div class="field">\n            <label for="age">Age</label>\n            <input type="text" id="age" name="age" />\n            <div class="error"></div>\n        </div>\n\n        <div class="field">\n            <label for="address">Address</label>\n            <input type="text" id="address" name="address" />\n            <div class="error"></div>\n        </div>\n\n        <div class="field">\n            <label for="password">This element will be ignored</label>\n            <input type="password" id="password" name="password" ignore />\n            <div class="error"></div>\n        </div>\n\n        <div>\n            <div class="col w-50">\n                <button type=\'reset\'>Reset</button>\n            </div>\n            <div class="col w-50 text-right">\n                <button type="submit">Submit</button>\n            </div>\n        </div>\n    </form>\n\n    <script>\n\n        import withFinalForm from \'@riot-tools/final-form\';\n\n        export default withFinalForm({\n\n            onUpdated() {\n\n                // this.finalForm becomes available after\n                // component has mounted. This gives direct\n                // access to the instantiated final form object\n                const form = this.finalForm();\n\n                if (this.state.likesCheese) {\n                    form.batch(() => {\n                        form.change(\'name\', \'pepelepew\');\n                        form.change(\'age\', 77);\n                    })\n                }\n            },\n\n            formElement() {\n                return this.$(\'form\');\n            },\n\n            // https://final-form.org/docs/final-form/types/Config#onsubmit\n            onSubmit(values) {\n                $api.post(\'/stuff\', values);\n            },\n\n            // https://final-form.org/docs/final-form/types/Config#initialvalues\n            initialValues: {\n                name: \'\',\n                age: null,\n                address: \'\'\n            },\n\n            // https://final-form.org/docs/final-form/types/Config#validate\n            validate(values) {\n                const errors = {};\n                if (!values.name) errors.name = \'name is required\';\n                if (!values.age) errors.age = \'age is required\';\n                if (!/^\\d+$/.test(values.age)) errors.age = \'age must be a number\';\n                return errors;\n            },\n\n            // https://final-form.org/docs/final-form/types/FormApi#subscribe\n            // https://final-form.org/docs/final-form/types/FormState\n            onFormChange(formState) {\n                const submit = this.formElement().querySelector(\'[type=submit]\');\n                submit.disabled = !formState.valid;\n            },\n\n            // https://final-form.org/docs/final-form/types/FormApi#registerfield\n            // `subscriber: FieldState => void`\n            // Omits `blur, change, focus` keys\n            onFieldChange(field, { touched, error, valid, visited, dirty }) {\n\n                const errorEl = field.parentElement.querySelector(\'.error\');\n\n                if (touched && error) {\n                    if (errorEl) errorEl.innerHTML = error;\n                    field.parentElement.classList.add(\'error\');\n                } else {\n                    if (errorEl) errorEl.innerHTML = \'\';\n                    field.parentElement.classList.remove(\'error\');\n                }\n            },\n\n            // https://final-form.org/docs/final-form/types/Config\n            // validate, initialValues, onSubmit, and destroyOnUnregister cannot be overwritten. `destroyOnUnregister` is always true.\n            formConfig: {\n                debug: true\n            },\n\n            // can be one of: active, dirty, dirtyFields, dirtySinceLastSubmit, error, errors, hasSubmitErrors, hasValidationErrors, initialValues, invalid, modified, pristine, submitting, submitError, submitErrors, submitFailed, submitSucceeded, touched, valid, validating, values, visited\n            formSubscriptions: {\n                visited: true,\n                dirty: true\n            },\n\n            // https://final-form.org/docs/final-form/types/FormApi#registerfield\n            // `subscription: { [string]: boolean }`\n            fieldSubscriptions: {\n                name: {\n                    pristine: true,\n                    valid: true\n                },\n                age: {\n                    submitFailed: true,\n                    valid: true\n                }\n            },\n            // https://final-form.org/docs/final-form/types/FieldConfig\n            // Based on a name basis. If your field name is `nested.stuff[0]`, then your config is `{ \'nested.stuff[0]\': { ... } }`\n            fieldConfigs: {\n                address: {\n                    afterSubmit: () => console.log(\'afterSubmit yay!!\')\n                }\n            }\n        });\n    <\/script>\n</some-form>\n')),(0,o.kt)("h2",{id:"manually-initialize-final-form"},"Manually initialize final form"),(0,o.kt)("p",null,"There may be cases where you want to manually initialize FF, such as when you depend on an XHR request to load initial values. For these scenarios, you can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"manuallyInitializeFinalForm")," flag on your component, and manually trigger ",(0,o.kt)("inlineCode",{parentName:"p"},"component.initializeFinalForm();")," inside of a lifecycle hook. Be cautious not to lose the lexical ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," of the ",(0,o.kt)("inlineCode",{parentName:"p"},"initializeFinalForm()")," function. If you need to deeply nest or pass a callback that later calls this, you can do so by extracting into self ",(0,o.kt)("inlineCode",{parentName:"p"},"const self = this;")," and binding it ",(0,o.kt)("inlineCode",{parentName:"p"},"initializeFinalForm.bind(self)"),"."),(0,o.kt)("h3",{id:"example"},"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},"<some-form>\n\n    ...\n\n    <script>\n\n        export default withFinalForm({\n            manuallyInitializeFinalForm: true,\n\n            // Simple async or sync usage\n            async onMounted() {\n\n                this.initialValues = await getStateFromSomewhere();\n\n                if (specificCondition) {\n\n                    this.validate = otherValidationFunction\n                }\n\n                this.initializeFinalForm();\n            }\n\n            // Nested lexical this\n            onMounted() {\n\n                // Reference component\n                const self = this;\n\n                getData().then((data) => {\n\n                    getMoreData().then(data2 => {\n\n                        self.initialValues = someData;\n\n                        // Must pass component for cases where you cannot\n                        // depend on lexical this\n                        self.initializeFinalForm.apply(self);\n                    })\n                });\n            }\n\n            // External configuration\n            onMounted() {\n\n                const self = this;\n\n                const callback = () => self.initializeFinalForm.apply(self);\n\n                // Dynamically configure any final form configs before applyings\n                dynamicallyConfigure(self, callback);\n            }\n        })\n    <\/script>\n</some-form>\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"Notes:"))),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("inlineCode",{parentName:"p"},"e.preventDefault()")," is called on submit unless explicitly specified otherwise. ",(0,o.kt)("a",{parentName:"p",href:"#enableDefaultBehaviorOption"},"See this"))),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Input fields can have an ",(0,o.kt)("inlineCode",{parentName:"p"},"ignore")," attribute attached to them which will flag them to be skipped for registration by final form. For example:"),(0,o.kt)("pre",{parentName:"blockquote"},(0,o.kt)("code",{parentName:"pre",className:"language-html"},"<input type='hidden' name='csrf_token' value='abc123' ignore />\n<input type='hidden' name='post_id' value='1' ignore />\n"))))}u.isMDXComponent=!0}}]);