"use strict";(self.webpackChunkriot_tools=self.webpackChunkriot_tools||[]).push([[286],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return f}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=c(t),f=a,d=m["".concat(s,".").concat(f)]||m[f]||p[f]||o;return t?r.createElement(d,i(i({ref:n},u),{},{components:t})):r.createElement(d,i({ref:n},u))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},2350:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return u},default:function(){return m}});var r=t(7462),a=t(3366),o=(t(7294),t(3905)),i=["components"],l={id:"sak-queryable",title:"Queryable",sidebar_label:"Queryable",slug:"/sak/queryable"},s=void 0,c={unversionedId:"sak/sak-queryable",id:"sak/sak-queryable",isDocsHomePage:!1,title:"Queryable",description:"This module adds functionality to riot components that allow them to set its own state to isFetching while an async call is being made. Any errors are recorded in the state's fetchError property.",source:"@site/docs/sak/queryable.md",sourceDirName:"sak",slug:"/sak/queryable",permalink:"/sak/queryable",editUrl:"https://github.com/riot-tools/riot-tools.github.io/edit/master/meiosis/docs/sak/queryable.md",version:"current",frontMatter:{id:"sak-queryable",title:"Queryable",sidebar_label:"Queryable",slug:"/sak/queryable"},sidebar:"sak",previous:{title:"Options Validator",permalink:"/sak/options-validator"},next:{title:"Meta",permalink:"/sak/meta"}},u=[{value:"Example",id:"example",children:[]},{value:"<code>setFetching(fn: Function): Promise&lt;any&gt;</code>",id:"setfetchingfn-function-promiseany",children:[]},{value:"<code>fnWillFetch(fn: Function): Function</code>",id:"fnwillfetchfn-function-function",children:[]},{value:"<code>makeFetching: string[]</code>",id:"makefetching-string",children:[]},{value:"Riot plugin",id:"riot-plugin",children:[]}],p={toc:u};function m(e){var n=e.components,t=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This module adds functionality to riot components that allow them to set its own state to ",(0,o.kt)("inlineCode",{parentName:"p"},"isFetching")," while an async call is being made. Any errors are recorded in the state's ",(0,o.kt)("inlineCode",{parentName:"p"},"fetchError")," property."),(0,o.kt)("p",null,"The component state becomes the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"type QueryableState<S> = S & {\n    isFetching?: boolean,\n    fetchError?: Error|null;\n};\n")),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},"<something>\n    \n    <div if={ state.isFetching }>loading...</div>\n    \n    <div if={ state.fetchError }>\n        { state.fetchError.message }\n    </div>\n\n    <script>\n\n        import { makeQueryable } from '@riot-tools/sak';\n\n        export default makeQueryable({\n\n            // Makes the function names in the component fetchables\n            makeFetching: ['onSubmit'],\n\n            async onSubmit(values) {\n\n                await api.post('/submit', values);\n            },\n\n            async someOtherFunction(check) {\n\n                if (check) {\n\n                    await this.setFetching(() => check());\n                }\n\n                // ... stuff\n            },\n\n            onMounted() {\n\n                // for when you to make a function fetchable at a later time\n                this.someFn = this.fnWillFetch(\n                    () => { /* ... */ }\n                );\n            }\n        })\n    <\/script>\n</something>\n")),(0,o.kt)("h2",{id:"setfetchingfn-function-promiseany"},(0,o.kt)("inlineCode",{parentName:"h2"},"setFetching(fn: Function): Promise<any>")),(0,o.kt)("p",null,"Updates the component fetching state and reset fetch errors. Whatever ",(0,o.kt)("inlineCode",{parentName:"p"},"fn")," returns will be spread onto the state."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"\nmakeQueryable({\n    state: {\n        test: 1\n    },\n\n    onMounted() {\n\n        this.setFetching(async () => {\n\n            const data = await api.get('/something');\n\n            // state will update to\n            // { data, test: 1, isFetching: false, fetchError: null }\n            return { data };\n        });\n    }\n})\n\n")),(0,o.kt)("h2",{id:"fnwillfetchfn-function-function"},(0,o.kt)("inlineCode",{parentName:"h2"},"fnWillFetch(fn: Function): Function")),(0,o.kt)("p",null,"Wraps a function with ",(0,o.kt)("inlineCode",{parentName:"p"},"setFetching()")," so it becomes a fetchable function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { makeQueryable } from '@riot-tools/sak';\n\nexport default makeQueryable({\n\n    onMounted() {\n        this.someFn = this.fnWillFetch(\n            () => { /* ... */ }\n        );\n    }\n})\n")),(0,o.kt)("h2",{id:"makefetching-string"},(0,o.kt)("inlineCode",{parentName:"h2"},"makeFetching: string[]")),(0,o.kt)("p",null,"Property you can add on a component which signals to wrap functions with ",(0,o.kt)("inlineCode",{parentName:"p"},"fnWillFetch()"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeQueryable({\n\n    makeFetching: [\n        'onSubmit',\n        'onMounted',\n    ],\n\n    async onSubmit(values) {\n\n        await api.post('/submit', values);\n    },\n\n    async onMounted() {\n        \n        const user = await api.get('/user');\n        const payments = await api.get('/payments');\n        const music = await api.get('/music');\n\n        // merge to state\n        return { user, payments, music }\n    }\n});\n")),(0,o.kt)("h2",{id:"riot-plugin"},"Riot plugin"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { makeQueryable } from '@riot-tools/sak';\nimport { install } from 'riot';\n\ninstall(component => makeQueryable(component));\n\n")))}m.isMDXComponent=!0}}]);