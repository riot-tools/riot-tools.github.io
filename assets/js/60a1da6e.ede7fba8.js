"use strict";(self.webpackChunkriot_tools=self.webpackChunkriot_tools||[]).push([[214],{6925:function(t,e,n){n.r(e),n.d(e,{frontMatter:function(){return r},contentTitle:function(){return m},metadata:function(){return p},toc:function(){return l},default:function(){return u}});var a=n(7462),s=n(3366),o=(n(7294),n(3905)),i=["components"],r={id:"meiosis-getting-started",title:"Getting Started",sidebar_label:"Getting Started",slug:"/meiosis/getting-started"},m=void 0,p={unversionedId:"meiosis/meiosis-getting-started",id:"meiosis/meiosis-getting-started",isDocsHomePage:!1,title:"Getting Started",description:"What is meiosis?",source:"@site/docs/meiosis/getting-started.md",sourceDirName:"meiosis",slug:"/meiosis/getting-started",permalink:"/meiosis/getting-started",editUrl:"https://github.com/riot-tools/riot-tools.github.io/edit/master/meiosis/docs/meiosis/getting-started.md",version:"current",frontMatter:{id:"meiosis-getting-started",title:"Getting Started",sidebar_label:"Getting Started",slug:"/meiosis/getting-started"},sidebar:"meiosis",next:{title:"API",permalink:"/meiosis/api"}},l=[{value:"What is meiosis?",id:"what-is-meiosis",children:[]},{value:"Key things to note",id:"key-things-to-note",children:[]},{value:"Usage",id:"usage",children:[]}],c={toc:l};function u(t){var e=t.components,n=(0,s.Z)(t,i);return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"what-is-meiosis"},"What is meiosis?"),(0,o.kt)("p",null,"Meiosis is a design pattern for managing application state using streams. Riot meiosis is an implementation of that pattern for Riot. ",(0,o.kt)("a",{parentName:"p",href:"https://meiosis.js.org/"},"Learn more about meiosis to understand the concept"),"."),(0,o.kt)("h2",{id:"key-things-to-note"},"Key things to note"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Implements a stream mechanism to update state"),(0,o.kt)("li",{parentName:"ul"},"Comes with a ",(0,o.kt)("inlineCode",{parentName:"li"},"connect")," function to wrap stream functionality"),(0,o.kt)("li",{parentName:"ul"},"Components attempt to update when updates are dispatched"),(0,o.kt)("li",{parentName:"ul"},"Prevent component updates if state has not changed"),(0,o.kt)("li",{parentName:"ul"},"Stream listeners are destroyed when ",(0,o.kt)("inlineCode",{parentName:"li"},"onBeforeUnmount"))),(0,o.kt)("h2",{id:"usage"},"Usage"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"npm i --save @riot-tools/meiosis\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"./appState.js")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import createStateStream from '@riot-tools/meiosis';\n\n// Set your initial state.\n// State is only mutable via manager API.\nconst state = {\n    initial: true,\n    isNew: true,\n    mutable: false,\n    nested: {\n        hasPasta: true\n    }\n};\n\n// Root state reducer\nconst reducer = (newState, oldState) => ({\n    ...oldState,\n    ...newState\n});\n\n// Create global app state instance\nconst appState = createStateStream(state);\n\n// Extract the state stream\nconst { stream } = appState;\n\nstream.addReducer(reducer);\n\n// stream is simply an Erre stream\nstream.dispatch({\n    initial: false,\n    isNew: false\n});\n\n// Gets an immutable clone of the current state\nconsole.log(stream.state());\n// > {\n//     initial: false,\n//     isNew: false,\n//     mutable: false,\n//     nested: {\n//         hasPasta: true\n//     }\n// }\n\nexport default appState;\n")),(0,o.kt)("p",null,"In your ",(0,o.kt)("inlineCode",{parentName:"p"},".riot")," files:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},"\n<myComponent>\n\n    <p if={ hasPasta }>I have pasta!</p>\n\n    <script>\n\n        import { connect } from './appState';\n        import myActions from './actions';\n\n        const mapToState = (appState, ownState, ownProps) => ({\n            ...ownState,\n            ...appState.nested\n        });\n\n        // Optional mapping of functions or objects to component\n        const mapToComponent = myActions;\n        // OR\n        const mapToComponent = (ownProps, ownState) => myActions;\n\n        const component = {\n\n            onBeforeMount() {\n\n                // connect will respect original onBeforeMount\n                this.state = {\n                    lala: true\n                }\n            },\n\n            onMounted() {\n\n                // Component will have access to dispatch from lexical this\n                this.dispatch({ myComponentMounted: true });\n            }\n        }\n\n        export default connect(mapToState)(component);\n        // OR\n        export default connect(mapToState, mapToComponent)(component);\n    <\/script>\n</myComponent>\n")))}u.isMDXComponent=!0}}]);